<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HandTrack Pro - –ñ–µ—Å—Ç–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ + Body Tracking</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
            cursor: none;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.1);
        }

        #videoContainer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 180px;
            height: 135px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
            display: none;
            z-index: 50;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            backdrop-filter: blur(15px);
            z-index: 100;
        }

        #gameMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            z-index: 100;
            display: none;
        }

        .menu-item {
            display: block;
            width: 350px;
            margin: 15px auto;
            padding: 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            border-radius: 15px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            text-align: center;
        }

        .menu-item:hover, .menu-item.selected {
            transform: scale(1.05);
            box-shadow: 0 15px 30px rgba(102, 126, 234, 0.4);
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
        }

        .start-button {
            background: linear-gradient(45deg, #00d2ff, #3a7bd5);
            font-size: 24px;
            padding: 20px 50px;
            margin: 20px;
        }

        #cursor {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            border: 4px solid #00d2ff;
            pointer-events: none;
            z-index: 1000;
            transition: all 0.05s ease;
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.5);
        }

        #cursor.pinching {
            background: #ff6b6b;
            border-color: #ff4757;
            transform: scale(1.5);
            box-shadow: 0 0 30px rgba(255, 107, 107, 0.8);
        }

        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            z-index: 90;
        }

        #backButton {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 15px 25px;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            display: none;
            z-index: 90;
        }

        #gameInfo {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 30px;
            border-radius: 25px;
            text-align: center;
            font-size: 18px;
            z-index: 80;
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(0, 210, 255, 0.6);
            transform: scale(0);
            animation: ripple-animation 0.6s ease-out;
            pointer-events: none;
            z-index: 500;
        }

        @keyframes ripple-animation {
            to {
                transform: scale(8);
                opacity: 0;
            }
        }

        .body-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #00ff00;
            border-radius: 50%;
            pointer-events: none;
            z-index: 60;
        }

        .connection-line {
            position: absolute;
            height: 2px;
            background: rgba(0, 255, 0, 0.7);
            transform-origin: left center;
            pointer-events: none;
            z-index: 55;
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 70;
        }

        #loadingText {
            margin-top: 20px;
            font-size: 16px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="videoContainer">
            <video id="video" autoplay muted playsinline></video>
        </div>

        <div id="startScreen">
            <h1>üöÄ HandTrack Pro + Body Games</h1>
            <p>–£–ø—Ä–∞–≤–ª—è–π –∂–µ—Å—Ç–∞–º–∏ —Ä—É–∫–∏ –∏ –≤—Å–µ–º —Ç–µ–ª–æ–º!</p>
            <button class="start-button" onclick="initSystems()">üéÆ –ó–∞–ø—É—Å—Ç–∏—Ç—å</button>
            <div id="loadingText"></div>
        </div>

        <div id="gameMenu">
            <h2>üéØ –í—ã–±–µ—Ä–∏ –∏–≥—Ä—É –ø–∏–Ω—á–µ–º:</h2>
            <div class="menu-item" data-game="breakout">üèì –ê—Ä–∫–∞–Ω–æ–∏–¥ (—Ä—É–∫–∞)</div>
            <div class="menu-item" data-game="shooter">üéØ –ö–æ—Å–º–æ-—à—É—Ç–µ—Ä (—Ä—É–∫–∞)</div>
            <div class="menu-item" data-game="snake">üêç –ó–º–µ–π–∫–∞ (—Ä—É–∫–∞)</div>
            <div class="menu-item" data-game="bubbles">ü´ß –ü—É–∑—ã—Ä–∏ (—Ä—É–∫–∞)</div>
            <div class="menu-item" data-game="draw">üé® –†–∏—Å–æ–≤–∞–Ω–∏–µ (—Ä—É–∫–∞)</div>
            <div class="menu-item" data-game="body-dodge">ü§∏ –£–∫–ª–æ–Ω–µ–Ω–∏–µ —Ç–µ–ª–æ–º (—Ç–µ–ª–æ)</div>
            <div class="menu-item" data-game="body-dance">üíÉ –¢–∞–Ω—Ü–µ–≤–∞–ª—å–Ω–∞—è –∏–≥—Ä–∞ (—Ç–µ–ª–æ)</div>
        </div>

        <button id="backButton" onclick="showMenu()">‚Üê –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é</button>

        <div id="stats">
            FPS: <span id="fps">0</span><br>
            –†—É–∫–∞: <span id="handStatus">‚è≥</span><br>
            –¢–µ–ª–æ: <span id="bodyStatus">‚è≥</span><br>
            –ü–∏–Ω—á: <span id="pinchStatus">‚ùå</span>
        </div>

        <div id="gameInfo"></div>
        <div id="cursor"></div>
    </div>

    <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.15.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet@2.2.2/dist/posenet.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // === –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–´ ===
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('video');
        const cursor = document.getElementById('cursor');
        const startScreen = document.getElementById('startScreen');
        const gameMenu = document.getElementById('gameMenu');
        const backButton = document.getElementById('backButton');
        const gameInfo = document.getElementById('gameInfo');
        const videoContainer = document.getElementById('videoContainer');

        let hands, camera, poseNet;
        let currentGame = null;
        let gameState = 'start';
        let handData = null;
        let bodyData = null;
        let isPinching = false;
        let lastPinchState = false;
        let selectedMenuItem = 0;
        let menuItems = [];

        // === –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø FPS ===
        let frameCount = 0;
        let lastTime = performance.now();
        let lastHandUpdate = 0;
        let lastBodyUpdate = 0;
        const HAND_UPDATE_INTERVAL = 16; // ~60 FPS
        const BODY_UPDATE_INTERVAL = 33; // ~30 FPS
        
        // === –†–ê–ó–ú–ï–†–´ –ö–ê–ù–í–ê–°–ê ===
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –°–ò–°–¢–ï–ú ===
        async function initSystems() {
            try {
                document.querySelector('.start-button').style.display = 'none';
                const loadingText = document.getElementById('loadingText');
                
                loadingText.textContent = 'üì∑ –ó–∞–ø—É—Å–∫ –∫–∞–º–µ—Ä—ã...';
                await initCamera();
                
                loadingText.textContent = 'üëã –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ–∫–∏–Ω–≥–∞ —Ä—É–∫...';
                await initHandTracking();
                
                loadingText.textContent = 'üèÉ –ó–∞–≥—Ä—É–∑–∫–∞ PoseNet...';
                await initBodyTracking();
                
                loadingText.textContent = '‚úÖ –ì–æ—Ç–æ–≤–æ!';
                
                setTimeout(() => {
                    startScreen.style.display = 'none';
                    showMenu();
                }, 500);

            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:', error);
                document.getElementById('loadingText').textContent = '‚ùå –û—à–∏–±–∫–∞: ' + error.message;
            }
        }

        // === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ö–ê–ú–ï–†–´ ===
        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        frameRate: { ideal: 60 }
                    },
                    audio: false
                });
                
                video.srcObject = stream;
                await new Promise(resolve => {
                    video.onloadedmetadata = resolve;
                });
                await video.play();
                videoContainer.style.display = 'block';

            } catch (error) {
                throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ');
            }
        }

        // === –¢–†–ï–ö–ò–ù–ì –†–£–ö ===
        async function initHandTracking() {
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0, // –ë—ã—Å—Ç—Ä–∞—è –º–æ–¥–µ–ª—å –¥–ª—è 60 FPS
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);

            camera = new Camera(video, {
                onFrame: async () => {
                    const now = performance.now();
                    if (now - lastHandUpdate > HAND_UPDATE_INTERVAL) {
                        await hands.send({ image: video });
                        lastHandUpdate = now;
                        updateFPS();
                    }
                },
                width: 640,
                height: 480
            });

            await camera.start();
        }

        // === –¢–†–ï–ö–ò–ù–ì –¢–ï–õ–ê ===
        async function initBodyTracking() {
            poseNet = await posenet.load({
                architecture: 'MobileNetV1',
                outputStride: 16,
                inputResolution: { width: 320, height: 240 }, // –ù–∏–∑–∫–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏
                multiplier: 0.5 // –ë—ã—Å—Ç—Ä–∞—è –º–æ–¥–µ–ª—å
            });

            // –ó–∞–ø—É—Å–∫ —Ç—Ä–µ–∫–∏–Ω–≥–∞ —Ç–µ–ª–∞
            setInterval(async () => {
                if (video.readyState >= 2) {
                    const now = performance.now();
                    if (now - lastBodyUpdate > BODY_UPDATE_INTERVAL) {
                        try {
                            const pose = await poseNet.estimateSinglePose(video, {
                                flipHorizontal: true
                            });
                            onBodyResults(pose);
                            lastBodyUpdate = now;
                        } catch (err) {
                            console.warn('Body tracking error:', err);
                        }
                    }
                }
            }, BODY_UPDATE_INTERVAL);
        }

        // === –û–ë–†–ê–ë–û–¢–ö–ê –î–ê–ù–ù–´–• –†–£–ö–ò ===
        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                processHandData(landmarks);
                document.getElementById('handStatus').textContent = '‚úÖ';
            } else {
                handData = null;
                isPinching = false;
                document.getElementById('handStatus').textContent = '‚ùå';
                document.getElementById('pinchStatus').textContent = '‚ùå';
            }
        }

        // === –£–õ–£–ß–®–ï–ù–ù–ê–Ø –û–ë–†–ê–ë–û–¢–ö–ê –ü–ò–ù–ß–ê ===
        function processHandData(landmarks) {
            const indexTip = landmarks[8];
            const thumbTip = landmarks[11];
            const indexMcp = landmarks[12];
            const thumbMcp = landmarks[13];

            // –ó–µ—Ä–∫–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è (–∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º X)
            const x = (1 - indexTip.x) * canvas.width;
            const y = indexTip.y * canvas.height;

            // –£–õ–£–ß–®–ï–ù–ù–û–ï –û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –ü–ò–ù–ß–ê
            const distance3D = Math.sqrt(
                Math.pow(indexTip.x - thumbTip.x, 2) +
                Math.pow(indexTip.y - thumbTip.y, 2) +
                Math.pow((indexTip.z || 0) - (thumbTip.z || 0), 2)
            );

            // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –æ—Å–Ω–æ–≤–∞–Ω–∏—è–º–∏ –¥–ª—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏
            const palmSize = Math.sqrt(
                Math.pow(indexMcp.x - thumbMcp.x, 2) +
                Math.pow(indexMcp.y - thumbMcp.y, 2)
            );

            // –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
            const normalizedDistance = distance3D / (palmSize + 0.01);

            lastPinchState = isPinching;
            isPinching = normalizedDistance < 0.6; // –ë–æ–ª–µ–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥

            handData = {
                x: x,
                y: y,
                isPinching: isPinching,
                justPinched: isPinching && !lastPinchState,
                justReleased: !isPinching && lastPinchState,
                landmarks: landmarks,
                confidence: results.multiHandLandmarks ? 1 : 0
            };

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—É—Ä—Å–æ—Ä–∞
            cursor.style.left = (x - 15) + 'px';
            cursor.style.top = (y - 15) + 'px';
            cursor.className = isPinching ? 'pinching' : '';

            document.getElementById('pinchStatus').textContent = isPinching ? '‚úÖ' : '‚ùå';

            // –≠—Ñ—Ñ–µ–∫—Ç –ø–∏–Ω—á–∞
            if (handData.justPinched) {
                createRipple(x, y);
                handleMenuInteraction();
            }
        }

        // === –û–ë–†–ê–ë–û–¢–ö–ê –î–ê–ù–ù–´–• –¢–ï–õ–ê ===
        function onBodyResults(pose) {
            if (pose && pose.score > 0.3) {
                bodyData = {
                    keypoints: pose.keypoints,
                    score: pose.score
                };
                document.getElementById('bodyStatus').textContent = '‚úÖ';
                
                if (gameState === 'playing' && (currentGame instanceof BodyDodgeGame || currentGame instanceof BodyDanceGame)) {
                    drawBodyPoints(pose.keypoints);
                }
            } else {
                bodyData = null;
                document.getElementById('bodyStatus').textContent = '‚ùå';
            }
        }

        // === –û–¢–†–ò–°–û–í–ö–ê –¢–û–ß–ï–ö –¢–ï–õ–ê ===
        function drawBodyPoints(keypoints) {
            // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ —Ç–æ—á–∫–∏
            document.querySelectorAll('.body-point, .connection-line').forEach(el => el.remove());

            const connections = [
                [5, 6], [5, 7], [7, 9], [6, 8], [8, 10], // –†—É–∫–∏
                [11, 12], [11, 13], [13, 15], [12, 14], [14, 16], // –ù–æ–≥–∏
                [5, 11], [6, 12] // –¢—É–ª–æ–≤–∏—â–µ
            ];

            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
            connections.forEach(([i, j]) => {
                const pointA = keypoints[i];
                const pointB = keypoints[j];
                
                if (pointA.score > 0.5 && pointB.score > 0.5) {
                    const line = document.createElement('div');
                    line.className = 'connection-line';
                    
                    const x1 = (1 - pointA.position.x / video.videoWidth) * canvas.width;
                    const y1 = (pointA.position.y / video.videoHeight) * canvas.height;
                    const x2 = (1 - pointB.position.x / video.videoWidth) * canvas.width;
                    const y2 = (pointB.position.y / video.videoHeight) * canvas.height;
                    
                    const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                    
                    line.style.left = x1 + 'px';
                    line.style.top = y1 + 'px';
                    line.style.width = length + 'px';
                    line.style.transform = `rotate(${angle}deg)`;
                    
                    document.body.appendChild(line);
                }
            });

            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ç–æ—á–µ–∫
            keypoints.forEach((keypoint, index) => {
                if (keypoint.score > 0.5) {
                    const point = document.createElement('div');
                    point.className = 'body-point';
                    
                    const x = (1 - keypoint.position.x / video.videoWidth) * canvas.width;
                    const y = (keypoint.position.y / video.videoHeight) * canvas.height;
                    
                    point.style.left = (x - 4) + 'px';
                    point.style.top = (y - 4) + 'px';
                    
                    document.body.appendChild(point);
                }
            });
        }

        // === –ù–ê–í–ò–ì–ê–¶–ò–Ø –ü–û –ú–ï–ù–Æ ===
        function handleMenuInteraction() {
            if (gameState === 'menu') {
                const items = document.querySelectorAll('.menu-item');
                if (items.length === 0) return;

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞ –∫–∞–∫–æ–π —ç–ª–µ–º–µ–Ω—Ç –Ω–∞–∂–∞–ª–∏
                let clickedIndex = -1;
                items.forEach((item, index) => {
                    const rect = item.getBoundingClientRect();
                    if (handData.x >= rect.left && handData.x <= rect.right &&
                        handData.y >= rect.top && handData.y <= rect.bottom) {
                        clickedIndex = index;
                    }
                });

                if (clickedIndex >= 0) {
                    const gameType = items[clickedIndex].dataset.game;
                    startGame(gameType);
                }
            }
        }

        // === –ü–û–ö–ê–ó –ú–ï–ù–Æ ===
        function showMenu() {
            gameState = 'menu';
            gameMenu.style.display = 'block';
            backButton.style.display = 'none';
            gameInfo.style.display = 'none';
            currentGame = null;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // –û—á–∏—â–∞–µ–º —Ç–æ—á–∫–∏ —Ç–µ–ª–∞
            document.querySelectorAll('.body-point, .connection-line').forEach(el => el.remove());
        }

        // === –ó–ê–ü–£–°–ö –ò–ì–†–´ ===
        function startGame(gameType) {
            gameState = 'playing';
            gameMenu.style.display = 'none';
            backButton.style.display = 'block';
            gameInfo.style.display = 'block';

            switch(gameType) {
                case 'breakout':
                    currentGame = new BreakoutGame();
                    break;
                case 'shooter':
                    currentGame = new ShooterGame();
                    break;
                case 'snake':
                    currentGame = new SnakeGame();
                    break;
                case 'bubbles':
                    currentGame = new BubbleGame();
                    break;
                case 'draw':
                    currentGame = new DrawGame();
                    break;
                case 'body-dodge':
                    currentGame = new BodyDodgeGame();
                    break;
                case 'body-dance':
                    currentGame = new BodyDanceGame();
                    break;
            }
        }

        // === –≠–§–§–ï–ö–¢–´ ===
        function createRipple(x, y) {
            const ripple = document.createElement('div');
            ripple.className = 'ripple';
            ripple.style.left = (x - 10) + 'px';
            ripple.style.top = (y - 10) + 'px';
            ripple.style.width = '20px';
            ripple.style.height = '20px';
            document.body.appendChild(ripple);
            setTimeout(() => ripple.remove(), 600);
        }

        function updateFPS() {
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }
        }

        // ==================== –ò–ì–†–´ ====================

        // === –ò–ì–†–ê 6: –£–ö–õ–û–ù–ï–ù–ò–ï –¢–ï–õ–û–ú ===
        class BodyDodgeGame {
            constructor() {
                this.obstacles = [];
                this.score = 0;
                this.lastObstacle = 0;
                this.playerHitbox = { x: canvas.width/2, y: canvas.height/2, radius: 50 };
            }

            update() {
                const now = Date.now();
                
                // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–º —á–µ—Ä–µ–∑ –ø–æ–∑–∏—Ü–∏—é —Ç–µ–ª–∞
                if (bodyData && bodyData.keypoints) {
                    const nose = bodyData.keypoints.find(kp => kp.part === 'nose');
                    if (nose && nose.score > 0.5) {
                        this.playerHitbox.x = (1 - nose.position.x / video.videoWidth) * canvas.width;
                        this.playerHitbox.y = (nose.position.y / video.videoHeight) * canvas.height;
                    }
                }

                // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
                if (now - this.lastObstacle > 800) {
                    this.obstacles.push({
                        x: Math.random() * canvas.width,
                        y: -50,
                        radius: 30 + Math.random() * 20,
                        speed: 3 + Math.random() * 4,
                        color: `hsl(${Math.random() * 360}, 70%, 50%)`
                    });
                    this.lastObstacle = now;
                }

                // –î–≤–∏–∂–µ–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
                this.obstacles = this.obstacles.filter(obs => {
                    obs.y += obs.speed;
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –∏–≥—Ä–æ–∫–æ–º
                    const dist = Math.sqrt(
                        Math.pow(obs.x - this.playerHitbox.x, 2) + 
                        Math.pow(obs.y - this.playerHitbox.y, 2)
                    );
                    
                    if (dist < obs.radius + this.playerHitbox.radius) {
                        this.gameOver();
                        return false;
                    }
                    
                    if (obs.y > canvas.height + 100) {
                        this.score += 10;
                        return false;
                    }
                    
                    return true;
                });
            }

            render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // –§–æ–Ω
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#1e3c72');
                gradient.addColorStop(1, '#2a5298');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
                this.obstacles.forEach(obs => {
                    ctx.fillStyle = obs.color;
                    ctx.beginPath();
                    ctx.arc(obs.x, obs.y, obs.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // –¢–µ–Ω—å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.beginPath();
                    ctx.arc(obs.x + 5, obs.y + 5, obs.radius, 0, Math.PI * 2);
                    ctx.fill();
                });

                // –ò–≥—Ä–æ–∫ (—Ö–∏—Ç–±–æ–∫—Å)
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.playerHitbox.x, this.playerHitbox.y, this.playerHitbox.radius, 0, Math.PI * 2);
                ctx.stroke();

                gameInfo.innerHTML = `ü§∏ –û—á–∫–∏: ${this.score} | –£–≤–æ—Ä–∞—á–∏–≤–∞–π—Å—è —Ç–µ–ª–æ–º –æ—Ç –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π!`;
            }

            gameOver() {
                alert(`ü§∏ –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –û—á–∫–∏: ${this.score}`);
                showMenu();
            }
        }

        // === –ò–ì–†–ê 7: –¢–ê–ù–¶–ï–í–ê–õ–¨–ù–ê–Ø –ò–ì–†–ê ===
        class BodyDanceGame {
            constructor() {
                this.targets = [];
                this.score = 0;
                this.lastTarget = 0;
                this.bodyParts = ['leftWrist', 'rightWrist', 'leftAnkle', 'rightAnkle', 'nose'];
                this.hitEffects = [];
            }

            update() {
                const now = Date.now();

                // –°–æ–∑–¥–∞–Ω–∏–µ —Ü–µ–ª–µ–π –¥–ª—è –∫–∞—Å–∞–Ω–∏—è
                if (now - this.lastTarget > 2000) {
                    const randomPart = this.bodyParts[Math.floor(Math.random() * this.bodyParts.length)];
                    this.targets.push({
                        bodyPart: randomPart,
                        x: 200 + Math.random() * (canvas.width - 400),
                        y: 150 + Math.random() * (canvas.height - 300),
                        radius: 60,
                        life: 3000,
                        color: `hsl(${Math.random() * 360}, 80%, 60%)`
                    });
                    this.lastTarget = now;
                }

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏–π
                if (bodyData && bodyData.keypoints) {
                    this.targets = this.targets.filter(target => {
                        const bodyPoint = bodyData.keypoints.find(kp => kp.part === target.bodyPart);
                        
                        if (bodyPoint && bodyPoint.score > 0.5) {
                            const bodyX = (1 - bodyPoint.position.x / video.videoWidth) * canvas.width;
                            const bodyY = (bodyPoint.position.y / video.videoHeight) * canvas.height;
                            
                            const dist = Math.sqrt(
                                Math.pow(bodyX - target.x, 2) + 
                                Math.pow(bodyY - target.y, 2)
                            );
                            
                            if (dist < target.radius) {
                                this.score += 50;
                                this.createHitEffect(target.x, target.y, target.color);
                                return false;
                            }
                        }
                        
                        target.life -= 16;
                        return target.life > 0;
                    });
                }

                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –ø–æ–ø–∞–¥–∞–Ω–∏–π
                this.hitEffects = this.hitEffects.filter(effect => {
                    effect.life -= 16;
                    effect.radius += 2;
                    effect.opacity = effect.life / 500;
                    return effect.life > 0;
                });
            }

            render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // –ö—Ä–∞—Å–∏–≤—ã–π —Ñ–æ–Ω
                const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // –¶–µ–ª–∏
                this.targets.forEach(target => {
                    const alpha = target.life / 3000;
                    
                    // –í–Ω–µ—à–Ω–∏–π –∫—Ä—É–≥
                    ctx.globalAlpha = alpha * 0.3;
                    ctx.fillStyle = target.color;
                    ctx.beginPath();
                    ctx.arc(target.x, target.y, target.radius + 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // –û—Å–Ω–æ–≤–Ω–æ–π –∫—Ä—É–≥
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = target.color;
                    ctx.beginPath();
                    ctx.arc(target.x, target.y, target.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // –ù–∞–∑–≤–∞–Ω–∏–µ —á–∞—Å—Ç–∏ —Ç–µ–ª–∞
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = 'white';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    const partName = {
                        'leftWrist': '–õ–µ–≤–∞—è —Ä—É–∫–∞',
                        'rightWrist': '–ü—Ä–∞–≤–∞—è —Ä—É–∫–∞',
                        'leftAnkle': '–õ–µ–≤–∞—è –Ω–æ–≥–∞',
                        'rightAnkle': '–ü—Ä–∞–≤–∞—è –Ω–æ–≥–∞',
                        'nose': '–ì–æ–ª–æ–≤–∞'
                    }[target.bodyPart];
                    ctx.fillText(partName, target.x, target.y + 5);
                });

                // –≠—Ñ—Ñ–µ–∫—Ç—ã –ø–æ–ø–∞–¥–∞–Ω–∏–π
                this.hitEffects.forEach(effect => {
                    ctx.globalAlpha = effect.opacity;
                    ctx.strokeStyle = effect.color;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                    ctx.stroke();
                });

                ctx.globalAlpha = 1;
                gameInfo.innerHTML = `üíÉ –û—á–∫–∏: ${this.score} | –ö–æ—Å–Ω–∏—Å—å —Ü–µ–ª–∏ –Ω—É–∂–Ω–æ–π —á–∞—Å—Ç—å—é —Ç–µ–ª–∞!`;
            }

            createHitEffect(x, y, color) {
                this.hitEffects.push({
                    x: x,
                    y: y,
                    radius: 30,
                    life: 500,
                    opacity: 1,
                    color: color
                });
            }
        }

        // === –û–°–¢–ê–õ–¨–ù–´–ï –ò–ì–†–´ (—É–ø—Ä–æ—â–µ–Ω–Ω—ã–µ –≤–µ—Ä—Å–∏–∏) ===
        class BreakoutGame {
            constructor() {
                this.paddle = { x: canvas.width/2, y: canvas.height - 50, width: 120, height: 20 };
                this.ball = { x: canvas.width/2, y: canvas.height/2, dx: 5, dy: -5, radius: 10 };
                this.bricks = [];
                this.score = 0;

                // –°–æ–∑–¥–∞–Ω–∏–µ –∫–∏—Ä–ø–∏—á–µ–π (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ)
                for(let row = 0; row < 4; row++) {
                    for(let col = 0; col < 8; col++) {
                        this.bricks.push({
                            x: col * 100 + 100,
                            y: row * 40 + 80,
                            width: 90,
                            height: 30,
                            destroyed: false,
                            color: `hsl(${row * 90}, 70%, 60%)`
                        });
                    }
                }
            }

            update() {
                if (!handData) return;

                this.paddle.x = handData.x - this.paddle.width / 2;
                
                this.ball.x += this.ball.dx;
                this.ball.y += this.ball.dy;

                if (this.ball.x < 0 || this.ball.x > canvas.width) this.ball.dx = -this.ball.dx;
                if (this.ball.y < 0) this.ball.dy = -this.ball.dy;

                if (this.ball.y > this.paddle.y - this.ball.radius &&
                    this.ball.x > this.paddle.x &&
                    this.ball.x < this.paddle.x + this.paddle.width) {
                    this.ball.dy = -Math.abs(this.ball.dy);
                    const hitPos = (this.ball.x - this.paddle.x) / this.paddle.width;
                    this.ball.dx = (hitPos - 0.5) * 10;
                }

                this.bricks.forEach(brick => {
                    if (!brick.destroyed &&
                        this.ball.x > brick.x &&
                        this.ball.x < brick.x + brick.width &&
                        this.ball.y > brick.y &&
                        this.ball.y < brick.y + brick.height) {
                        
                        brick.destroyed = true;
                        this.ball.dy = -this.ball.dy;
                        this.score += 10;
                        createRipple(brick.x + brick.width/2, brick.y + brick.height/2);
                    }
                });

                if (this.ball.y > canvas.height) {
                    alert(`üèì –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –û—á–∫–∏: ${this.score}`);
                    showMenu();
                }
            }

            render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                this.bricks.forEach(brick => {
                    if (!brick.destroyed) {
                        ctx.fillStyle = brick.color;
                        ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    }
                });

                ctx.fillStyle = '#00d2ff';
                ctx.fillRect(this.paddle.x, this.paddle.y, this.paddle.width, this.paddle.height);

                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
                ctx.fill();

                gameInfo.innerHTML = `üèì –û—á–∫–∏: ${this.score} | –£–ø—Ä–∞–≤–ª—è–π —Ä—É–∫–æ–π!`;
            }
        }

        // –î–æ–±–∞–≤–ª—é –∑–∞–≥–ª—É—à–∫–∏ –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∏–≥—Ä
        class ShooterGame {
            constructor() { this.score = 0; }
            update() {}
            render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üéØ –ö–æ—Å–º–æ-—à—É—Ç–µ—Ä', canvas.width/2, canvas.height/2);
                gameInfo.innerHTML = '–ò–≥—Ä–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ...';
            }
        }

        class SnakeGame {
            constructor() { this.score = 0; }
            update() {}
            render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üêç –ó–º–µ–π–∫–∞', canvas.width/2, canvas.height/2);
                gameInfo.innerHTML = '–ò–≥—Ä–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ...';
            }
        }

        class BubbleGame {
            constructor() { this.score = 0; }
            update() {}
            render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ü´ß –ü—É–∑—ã—Ä–∏', canvas.width/2, canvas.height/2);
                gameInfo.innerHTML = '–ò–≥—Ä–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ...';
            }
        }

        class DrawGame {
            constructor() { this.score = 0; }
            update() {}
            render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üé® –†–∏—Å–æ–≤–∞–Ω–∏–µ', canvas.width/2, canvas.height/2);
                gameInfo.innerHTML = '–ò–≥—Ä–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ...';
            }
        }

        // === –û–°–ù–û–í–ù–û–ô –ò–ì–†–û–í–û–ô –¶–ò–ö–õ ===
        function gameLoop() {
            requestAnimationFrame(gameLoop);
            
            if (gameState === 'playing' && currentGame) {
                currentGame.update();
                currentGame.render();
            }
        }

        gameLoop();
    </script>
</body>
</html>
